<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="textBox1.Text" xml:space="preserve">
    <value>한학기동안 교수님과 C#수업을 들을 수 있어서 즐거웠습니다.
알고 계셨을것이라 생각합니다만 저는 프로그래밍을 꽤 오래했었습니다. 어렸을 때부터 컴퓨터로 무언가를 만들어내는걸 좋아해서 초등학교적, 플래시 8 버전이었을때 인터넷상에 있는 각종 게시글(공략글)들을 참고하면서 게임을 만든적이 있었습니다.

http://flash365.dreamx.com/game/zboard.php?id=author&amp;page=1&amp;sn1=&amp;divpage=1&amp;sn=off&amp;ss=on&amp;sc=on&amp;keyword=show%C7%C3&amp;select_arrange=headnum&amp;desc=asc&amp;no=109664

(9년이 지나고 지금보니 이때의 저도 꽤 대단했다는 생각이 들었네요.)
선린인터넷고등학교를 입학하고서부터 본격적으로 프로그래밍을 시작한지 4년차가 되고 나서보니, 지금도 무언가를 프로그래밍 해서 만드는 것에 대해 재미를 느끼고 적성에도 잘 맞는다고 생각하고 있습니다.

이번 계산기를 만드는 과제를 하면서 C#수업이 가장 재미있다고 느낀건, 이미 알고 있는 내용을 수업시간에 교수님이 하는대로 따라하는 것 대신에 직접 계산기 구조를 처음부터 설계하고 그거대로 저만의 계산기를 만들 수 있었다는 것에 있었습니다. 그리고 교수님이 알려주신 내용을 기반으로, 추가로 더 검색하면서 찾아보고 하면서 스스로 공부한 시간도 재미있었습니다.

저처럼 다른 구조로 계산기를 짠 학생들중에서 제 코드와 김민석이 짠 코드는 많이 참고 해주셨으면 좋겠습니다. 저랑 민석이는 서로 코드 참고하면서 공부하고 있는게 많으니까요. 그리고 끝으로... 교수님이 학생들에게 프로그래밍을 가르쳐주시는 것에 따라서 몇가지 부탁드릴 점들을 남기면서 마치겠습니다. 한학기동안 c#수업 해주셔서 고마웠습니다.


- 메소드와 컨트롤 이름은 다른 사람이 이름을 보고 직관적으로 어떤 역활을 하는 것인지 알아볼 수 있도록 설정해야합니다. 지금까지 교수님이 짠 모든 버튼들의 이름을 기본값인 Button_1, Button_2 등으로 사용했었는데, 이는 .Net Framework 명명 가이드라인에 위반되고, 실제로 코딩하면서 뭐가 무엇을 뜻하는지 직관적으로 알아보기 힘들게 됩니다. iOperation과 같은 메소드명도, i가 무엇을 뜻하는지 주석에 정확히 명시하거나, 표준 사전에 적혀있는 단어를 사용하는 것을 권장하고 있습니다.

- 메소드(함수)를 파편화하고 재사용 할 수 있는 구조로 설계하는것이 좋습니다. 특히 '똑같거나 비슷한 Line이 반복되는 경우', 이를 한꺼번에 처리하는 함수를 따로 생성하고 그것을 호출해서 사용하는 것이 속도, 메모리 관리, 가독성 모든측에서 훨씬 효율적입니다. 

- 컨트롤 이벤트(버튼클릭 이벤트 등)는 최대한 간결하게 작성하는것이 좋습니다. 바로 이전에 언급한 함수의 파편화와 곂치는 내용이지만, 예를들어 버튼 클릭할때의 일련의 과정을 다른 방법으로(ex. 키보드로 버튼클릭) 호출하려면 불필요한 이벤트가 많이 발생하게 됩니다. 저 같은경우는 대부분의 버튼 클릭을 함수 호출 한개로 줄인뒤, 람다식으로 작성했습니다. 
NUM1_Click(object sender, EventArgs e) =&gt; AddOperandToScreen('1'); 이런식으로요.
NUM1_Click(object sender, EventArgs e) {
	AddOperandToScreen('1');
} 이랑 똑같습니다.

- 어떤 자식 폼을 닫고 나서 부모폼을 닫으려할때, Dispose(); 함수를 사용해주세요.
메소드 설명에도 나와있지만, Dispose는 폼을 구성하는데 사용했던 구성요소들의 리소스들을 전부 해제하는 함수입니다.
공학용 계산기를 열고나서 공학용 계산기를 닫으면 프로세스가 종료되지 않는 문제를 해결할 수 있습니다.
Form_Closed이벤트가 발생했을 때, Dispose함수를 사용해서 리소스를 해제하는 방법이 가장 흔한 것 같습니다. 또한 폼을 우측상단의 x버튼을 눌러서 끌때 Form_Closing 이벤트가 발생하는데, 이때 Close();를 사용하면 해당 폼을 종료시킬 수 있습니다.</value>
  </data>
</root>